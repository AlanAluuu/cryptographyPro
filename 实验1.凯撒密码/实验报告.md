## 实验一

### 古典密码算法-Kaiser密码

##### 一、实验目的

1. 熟悉VC++6.0系统，设计实现一个Caesar加密工具，完成对文件的加解密。
2. 对实验结果进行分析和评价。

##### 二、实验所用仪器（或实验环境）

​	Dev C++

##### 三、实验基本原理及步骤（或方案设计及理论计算）

**基本原理：**凯撒密码是一种简单的密码算法，也被称为移位密码。它的原理很简单：将明文中的每个字母按照固定的偏移量（例如向右移动三个位置）进行移位，得到密文。解密过程也很简单：将密文中的每个字母反向移动同样的偏移量，即可还原出明文。

**代码解析：**main函数如下

```c
int main(){
    FILE *fpr,*fpw;
    int m = 0;
    do
	{
		printf("加密请输入1\n解密请输入2\n退出请输入0\n");
	    scanf("%d",&m);
	    if(m==0)
	    	break;
	    else if(m!=0&&m!=1&&m!=2)
	    	printf("输入有误，请重新输入！\n");
	    else{
	    	int len = 0,i = 0,k = 0;
		    printf("请输入密钥k\n");
		    scanf("%d",&k);
	    	if(m==1){   
		    	char ch,c[10000]={0},e[10000]={0};
		        fpr = fopen("p.txt","r");
		        fpw = fopen("c.txt","w");
		        if(fpr==NULL){
		            printf("open file error\n");
		            return 1;
			    }
		        while(fscanf(fpr,"%c",&ch)!=EOF){
		            c[i] = ch;
		            i++;
		            len++;
		        }
		        encrypt(c,len,k,e,fpw);
		        fclose(fpr);
				fclose(fpw);
		    }
		    else if(m==2)
		    {
		    	char ch,c[10000]={0},d[10000]={0};
		        fpr = fopen("c.txt","r");
		        fpw = fopen("d.txt","w");
		        if(fpr==NULL){
		            printf("open file error\n");
		            return 1;
			    }
		        while(fscanf(fpr,"%c",&ch)!=EOF){
		            c[i] = ch;
		            i++;
		            len++;
		        }
		        decrypt(c,len,k,d,fpw);
		        fclose(fpr);
				fclose(fpw);
		    }
		}
	}while(m!=0);
	return 0;
}
```

在 `main` 函数中首先要求用户输入执行加密或解密操作的选项，然后再根据用户选择的操作类型分别执行对应的操作。在执行操作之前，用户需要输入密钥值 k，该值会作为加密解密算法的参数。在加密操作中，程序会读取指定文件中的明文，并将加密结果写入到另一个指定文件中；在解密操作中，程序会读取指定文件中的密文，并将解密结果写入到另一个指定文件中。

加密算法encrypt如下

```c
//k为密钥,len为长度,fp为储存的加密文件
void encrypt(char c[],int len,int k,char e[],FILE *fp){
    int i = 0;
    for(i=0;i<len;i++){
        if(c[i]>='a'&&c[i]<='z'-k){
            e[i] = c[i] + k;
        }
        else if(c[i]>='a'&&c[i]>'z'-k){
            e[i] = c[i] + k - 26;
        }
        else if(c[i]>='A'&&c[i]<='Z'-k){
            e[i] = c[i] + k;
        }
        else if(c[i]>='A'&&c[i]>'Z'-k){
            e[i] = c[i] + k - 26;
        }
        else{
            e[i] = c[i];
        }
    }
    fputs(e,fp);
    printf("加密方成功进行加密！\n");
} 
```

`encrypt` 函数实现了加密过程，接收4个参数：原始消息字符串、字符串长度、密钥值以及用于存储加密结果的字符串数组，最后将结果写入指定文件中。加密算法中使用了一种简单的移位方法，将每个字符的ASCII码增加密钥值 k，如果超出字母 'z' 或 'Z' 的范围则需要回到字母表开头处。否则，不做任何更改。

解密算法decrypt如下所示

```c
void decrypt(char c[],int len,int k,char d[],FILE *fp)
{
    int i = 0;
    for(i=0;i<len;i++){
        if(c[i]>='a'+k&&c[i]<='z'){
            d[i] = c[i] - k;
        }
        else if(c[i]>='a'&&c[i]<'a'+k){
            d[i] = c[i] - k + 26;
        }
        else if(c[i]>='A'+k&&c[i]<='Z'){
            d[i] = c[i] - k;
        }
        else if(c[i]>='A'&&c[i]<'A'+k){
            d[i] = c[i] - k + 26;
        }
        else{
            d[i] = c[i];
        }
    }
    fputs(d,fp);
    printf("解密方成功进行解密！\n");
} 
```

`decrypt` 函数实现了解密过程，接收4个参数：密文字符串、字符串长度、密钥值以及用于存储解密结果的字符串数组，最后将结果写入指定文件中。解密算法中同样采用了移位方法，但是需要将增加的密钥值 k 换成减少的密钥值 k。

##### 四、实验数据记录（或仿真及软件设计）

先对明文文件p.txt进行加密，密钥k为3，加密后的内容存储到c.txt中。再对密文文件c.txt进行解密，密钥值为3，解密后的结果存放到d.txt中

![image-20230525210623324](screenshots/1.1.png)

明文文件、密文文件以及解密文件内容如下所示

![image-20230525211731731](screenshots/1.2.png)

利用给的小工具对加密解密流程进行测试，可以看出加解密流程正确

![image-20230525212247430](screenshots/1.3.png)

##### 五、实验结果分析及回答问题（或测试环境及测试结果）

1. 在手动完成Caesar密码实验中，密钥k=3，试着画出这时的Caesar置换表？

   | **明文** | **A** | B     | C     | D     | E     | F     | G     | H     | I     | G     | K     | L     | M     |
   | -------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
   | **密文** | D     | E     | F     | G     | H     | I     | J     | K     | L     | M     | N     | O     | P     |
   | **明文** | **N** | **O** | **P** | **Q** | **R** | **S** | **T** | **U** | **V** | **W** | **X** | **Y** | **Z** |
   | **密文** | Q     | R     | S     | T     | U     | V     | W     | X     | Y     | Z     | A     | B     | C     |

2. 古典密码学曾经被广泛应用，它可以分为代替密码和置换密码两种，请查找相关资料，列举出几种属于代替密码和置换密码的古典密码算法？

   代替密码：

   - 凯撒密码：将明文中的每个字母向右移动一个固定数量的位置，比如向右移动3个位置。
   - 维吉尼亚密码：结合了多个凯撒密码，通过使用不同的移动量来加密每个字母。
   - Hill密码：使用矩阵乘法来加密明文中的每个字母。
   - RC4：一种流密码，使用伪随机数生成器生成密钥流，再将其与明文异或运算得到密文。

   置换密码：

   - 栅栏密码：将明文按照一定规则分成若干组，然后将每组中的字母重新排列。
   - 简单替换密码：使用一个简单的固定字母表来加密明文，即将明文中的每个字母替换为另一个字母。
   - 频率分析密码：利用字母出现频率的统计规律来猜测密文中的字母，从而解密消息。
   - Playfair密码：将明文中的每个字母映射到一个二维矩阵中的两个字母，然后将这两个字母替换为矩阵中的另外两个字母。

   
