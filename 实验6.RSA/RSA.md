## 实验六

### 非对称密码算法-RSA密码

##### 一、实验目的

1. 掌握RSA生成公钥私钥的过程；

2. 熟练掌握利用RSA密钥对指定内容的加解密进程。
3. 设计RSA加密工具，利用RSA加密算法对文件进行加密。

##### 二、实验所用仪器（或实验环境）

​	Dev C++

##### 三、实验基本原理及步骤（或方案设计及理论计算）

RSA（Rivest–Shamir–Adleman）是一种非对称加密算法，其加解密过程如下：

1. 密钥生成：随机生成两个大素数p和q，并计算模数n=p\*q、φ(n)=(p-1)\*(q-1)，选择一个整数e（1<e<φ(n)）作为公钥，使得e和φ(n)互质，然后计算d，使得d*e = 1 (mod φ(n))，即d是e在模φ(n)意义下的乘法逆元。公钥为{e, n}，私钥为{d, n}。
2. 加密：将明文转换成整数M（通常使用编码方案进行转换），然后用公钥{e, n}来计算密文C = M^e (mod n)。
3. 解密：接收到密文C后，使用私钥{d, n}来计算出明文M = C^d (mod n)。

主函数如下

```c++
int main() {
	//p,q为素数，e为公钥，d为私钥，m为明文，n为模数 ,c为密文 
	int p, q, e, d, m, n, t, c, r, k;
	printf("请输入两个素数p,q:");
	while (1){
		scanf("%d%d", &p, &q);
		//判断两个数是否为素数，不是的话重新输入
		if ((Prime(p) == 1) && (Prime(q) == 1)){  
			n = p*q;
			break;
		}
		else printf("ERROR!\n请重新输入两个素数p,q\n");
	}
	//求欧拉函数t
	t = (p - 1)*(q - 1);      
	printf("请输入你想设置的公钥e，注意：1<e<φ(n)，且e与(p - 1)*(q - 1)互质。e:");
	scanf("%d", &e);

	while (e<1 || e>t || husu(e, t)){
		printf("ERROR!e不符合要求！请重新输入e:\n");
		scanf("%d", &e);
	}

	d = 1;
	//由公钥e求出私钥d
	while (((e*d) % t) != 1)   
		d++;     
	printf("计算出的私钥d:%d\n",d);
	printf("请输入想要加密的明文:");
	scanf("%d", &m);
	c = encrypt(m, e, n);
	printf("密文为: %d\n", c);
	printf("请输入密文:");
	scanf("%d", &c);
	m = encrypt(c, d, n);
	printf("明文为: %d", m);
}
```

主函数实现了一个基本的RSA加密算法。通过获取输入的两个素数p和q，计算得到模数n。然后输入公钥e，公钥e应该满足1<e<φ(n)，且e与(p - 1)*(q - 1)互质，所以会对输入的e进行一个是否是素数的判断。再根据欧拉函数求出私钥d。然后将明文m加密为密文c，并输出密文；同时也能将密文解密为明文。在加密和解密过程中，使用了encrypt()函数来实现加解密操作。encrypt()函数实际上是是一个幂取余的过程。

下面是判断整数是否为素数的函数Prime(int m)，其输入参数为一个整数m。这个函数用于判断输入的p,q是否是素数。

```c++
int Prime(int m){    
	int i, k;
	if (m<2) return 0;
	k = sqrt(m);
	for (i = 2; i <= k; i++)
		if (m%i == 0)
			break;
	 //素数返回1,否则返回0
	if (i>k)   
		return 1;                  
	else
		return 0;                    
}
```

这段代码的实现逻辑如下：

- 首先，如果输入的m小于2，直接返回0，因为小于2的数都不是素数。
- 接着，定义变量k等于m的平方根（sqrt(m)）向下取整的值，这是因为一个数如果有因子n，那么必定存在另一个因子m/n。而且n和m/n中必有一个小于或等于sqrt(m)，另一个大于或等于sqrt(m)。因此只需要从2遍历到k就可以找到m的所有因子，从而判断m是否为素数。
- 然后使用for循环，从2开始遍历到k，依次判断m能否被i整除。如果存在可以整除的i，则跳出循环。
- 最后，在循环结束后，检查i是否大于k。若大于k，说明m没有除了1和自身之外的其它因子，即m是素数，返回1；否则，说明m有其他因子，返回0。

下面是判断两数是否互素的函数，主要用于判断公钥e是否与(p - 1)*(q - 1)互质

```c++
int husu(int x, int y){   
	int t;
	while (y){
		t = x;
		x = y;
		y = t%y;
	}
	//x与y互素时返回0，x与y不互素时返回1  
	if (x == 1) 
		return 0;           
	else  
		return 1;   
}
```

这个函数的具体实现流程如下：

- 首先，使用while循环进行辗转相除法（又称欧几里得算法），求出x和y的最大公约数，保存在变量t中，直到y等于0，此时x就是x和y的最大公约数。
- 然后，如果x等于1，说明x和y互质，因为只有当两个数的最大公约数为1时，它们才是互质的，返回0。
- 最后，如果x不等于1，说明x和y不互质，返回1。

下面是加密解密用到的函数，这段代码实现了一个简单的模幂运算，其中a为明文，b为指数，c为模数。

```c++
int encrypt(int a, int b, int c){
	int r = 1;
	b = b + 1;
	while (b != 1){
		r = r*a;
		r = r%c;
		b--;
	}
	return r;
}
```

##### 四、实验数据记录（或仿真及软件设计）

输入两个素数p=47，q=59，则n=p\*q，再输入设置的公钥e=63，满足了1<e<φ(n)，且e与(p - 1)*(q - 1)互质。计算出的私钥d为847，进行加密后密文c=m^e (mod n)为1692，密文解密后的结果m = c^d (mod n)为188.

![img](https://github.com/AlanAluuu/cryptographyPro/blob/main/screenshots/6.1.png)

利用给出的小工具去判断加密解密流程是否正确，注意这里公钥63的格式应该输入成十六进制的3f，右侧的进制选择10，明文选项选择大数。通过使用工具验证，可知RSA加解密流程正确。

![img](https://github.com/AlanAluuu/cryptographyPro/blob/main/screenshots/6.2.png)

##### 五、实验结果分析及回答问题（或测试环境及测试结果）

1、简述RSA的公钥生成算法

RSA公钥生成算法的步骤如下：

1. 随机选择两个不相等的质数p和q
2. 计算n = p * q
3. 计算欧拉函数φ(n) = (p-1) * (q-1)
4. 随机选择一个整数e，满足1 < e < φ(n)，且e与φ(n)互质（即它们没有除了1以外的公共因子）
5. 计算e关于模φ(n)的乘法逆元d，即d ≡ e⁻¹ (mod φ(n))
6. 公钥为(n, e)，私钥为(n, d)

其中，公钥由(n, e)组成，私钥由(n, d)组成。在实际使用中，p和q应该足够大并且随机选择，以确保 RSA 的安全性

2、“无法证明RSA算法是安全的”，你认为这句话对吗？

在密码学中，任何算法都无法被证明是绝对安全的，因为即使看似很安全的算法仍然可能被攻击者破解或者利用漏洞攻击。RSA算法也不例外。RSA算法的安全性与所选用的素数的长度有直接关系。一般来说，选用更长的素数会使攻击者通过暴力破解的难度增大，从而提高了RSA算法的安全性。总之，虽然没有一种加密算法可以被完全证明是绝对安全的，但是，如果正确使用并采取适当的安全措施，RSA算法可以提供足够的保护来满足大部分实际安全需求。





